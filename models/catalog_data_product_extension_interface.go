// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// CatalogDataProductExtensionInterface ExtensionInterface class for @see \Magento\Catalog\Api\Data\ProductInterface
//
// swagger:model catalog-data-product-extension-interface
type CatalogDataProductExtensionInterface struct {

	// bundle product options
	BundleProductOptions []*BundleDataOptionInterface `json:"bundle_product_options"`

	// category links
	CategoryLinks []*CatalogDataCategoryLinkInterface `json:"category_links"`

	// configurable product links
	ConfigurableProductLinks []int64 `json:"configurable_product_links"`

	// configurable product options
	ConfigurableProductOptions []*ConfigurableProductDataOptionInterface `json:"configurable_product_options"`

	// downloadable product links
	DownloadableProductLinks []*DownloadableDataLinkInterface `json:"downloadable_product_links"`

	// downloadable product samples
	DownloadableProductSamples []*DownloadableDataSampleInterface `json:"downloadable_product_samples"`

	// stock item
	StockItem *CatalogInventoryDataStockItemInterface `json:"stock_item,omitempty"`

	// vertex commodity code
	VertexCommodityCode *VertexTaxDataCommodityCodeInterface `json:"vertex_commodity_code,omitempty"`

	// website ids
	WebsiteIds []int64 `json:"website_ids"`
}

// Validate validates this catalog data product extension interface
func (m *CatalogDataProductExtensionInterface) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateBundleProductOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCategoryLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateConfigurableProductOptions(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadableProductLinks(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDownloadableProductSamples(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateStockItem(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVertexCommodityCode(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CatalogDataProductExtensionInterface) validateBundleProductOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.BundleProductOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.BundleProductOptions); i++ {
		if swag.IsZero(m.BundleProductOptions[i]) { // not required
			continue
		}

		if m.BundleProductOptions[i] != nil {
			if err := m.BundleProductOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bundle_product_options" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bundle_product_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) validateCategoryLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.CategoryLinks) { // not required
		return nil
	}

	for i := 0; i < len(m.CategoryLinks); i++ {
		if swag.IsZero(m.CategoryLinks[i]) { // not required
			continue
		}

		if m.CategoryLinks[i] != nil {
			if err := m.CategoryLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("category_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("category_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) validateConfigurableProductOptions(formats strfmt.Registry) error {
	if swag.IsZero(m.ConfigurableProductOptions) { // not required
		return nil
	}

	for i := 0; i < len(m.ConfigurableProductOptions); i++ {
		if swag.IsZero(m.ConfigurableProductOptions[i]) { // not required
			continue
		}

		if m.ConfigurableProductOptions[i] != nil {
			if err := m.ConfigurableProductOptions[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configurable_product_options" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("configurable_product_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) validateDownloadableProductLinks(formats strfmt.Registry) error {
	if swag.IsZero(m.DownloadableProductLinks) { // not required
		return nil
	}

	for i := 0; i < len(m.DownloadableProductLinks); i++ {
		if swag.IsZero(m.DownloadableProductLinks[i]) { // not required
			continue
		}

		if m.DownloadableProductLinks[i] != nil {
			if err := m.DownloadableProductLinks[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("downloadable_product_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("downloadable_product_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) validateDownloadableProductSamples(formats strfmt.Registry) error {
	if swag.IsZero(m.DownloadableProductSamples) { // not required
		return nil
	}

	for i := 0; i < len(m.DownloadableProductSamples); i++ {
		if swag.IsZero(m.DownloadableProductSamples[i]) { // not required
			continue
		}

		if m.DownloadableProductSamples[i] != nil {
			if err := m.DownloadableProductSamples[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("downloadable_product_samples" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("downloadable_product_samples" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) validateStockItem(formats strfmt.Registry) error {
	if swag.IsZero(m.StockItem) { // not required
		return nil
	}

	if m.StockItem != nil {
		if err := m.StockItem.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stock_item")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stock_item")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) validateVertexCommodityCode(formats strfmt.Registry) error {
	if swag.IsZero(m.VertexCommodityCode) { // not required
		return nil
	}

	if m.VertexCommodityCode != nil {
		if err := m.VertexCommodityCode.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vertex_commodity_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vertex_commodity_code")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this catalog data product extension interface based on the context it is used
func (m *CatalogDataProductExtensionInterface) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateBundleProductOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCategoryLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateConfigurableProductOptions(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDownloadableProductLinks(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateDownloadableProductSamples(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateStockItem(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVertexCommodityCode(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CatalogDataProductExtensionInterface) contextValidateBundleProductOptions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.BundleProductOptions); i++ {

		if m.BundleProductOptions[i] != nil {
			if err := m.BundleProductOptions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("bundle_product_options" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("bundle_product_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) contextValidateCategoryLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CategoryLinks); i++ {

		if m.CategoryLinks[i] != nil {
			if err := m.CategoryLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("category_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("category_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) contextValidateConfigurableProductOptions(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.ConfigurableProductOptions); i++ {

		if m.ConfigurableProductOptions[i] != nil {
			if err := m.ConfigurableProductOptions[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("configurable_product_options" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("configurable_product_options" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) contextValidateDownloadableProductLinks(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DownloadableProductLinks); i++ {

		if m.DownloadableProductLinks[i] != nil {
			if err := m.DownloadableProductLinks[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("downloadable_product_links" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("downloadable_product_links" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) contextValidateDownloadableProductSamples(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.DownloadableProductSamples); i++ {

		if m.DownloadableProductSamples[i] != nil {
			if err := m.DownloadableProductSamples[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("downloadable_product_samples" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("downloadable_product_samples" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) contextValidateStockItem(ctx context.Context, formats strfmt.Registry) error {

	if m.StockItem != nil {
		if err := m.StockItem.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("stock_item")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("stock_item")
			}
			return err
		}
	}

	return nil
}

func (m *CatalogDataProductExtensionInterface) contextValidateVertexCommodityCode(ctx context.Context, formats strfmt.Registry) error {

	if m.VertexCommodityCode != nil {
		if err := m.VertexCommodityCode.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vertex_commodity_code")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vertex_commodity_code")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *CatalogDataProductExtensionInterface) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CatalogDataProductExtensionInterface) UnmarshalBinary(b []byte) error {
	var res CatalogDataProductExtensionInterface
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
